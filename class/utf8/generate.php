<?php /*********************************************************************
 *
 *   Copyright : (C) 2006 Nicolas Grekas. All rights reserved.
 *   Email     : nicolas.grekas+patchwork@espci.org
 *   License   : http://www.gnu.org/licenses/lgpl.txt GNU/LGPL, see LGPL
 *
 *   This library is free software; you can redistribute it and/or
 *   modify it under the terms of the GNU Lesser General Public
 *   License as published by the Free Software Foundation; either
 *   version 2.1 of the License, or (at your option) any later version.
 *
 ***************************************************************************/


class
{
	static $utf8Data;
	static $DerivedNormalizationProps = 'http://www.unicode.org/Public/UNIDATA/DerivedNormalizationProps.txt';
	static $UnicodeData               = 'http://www.unicode.org/Public/UNIDATA/UnicodeData.txt';
	static $CompositionExclusions     = 'http://www.unicode.org/Public/UNIDATA/CompositionExclusions.txt';

	static function __static_construct()
	{
		self::$utf8Data = resolvePath('data/utf8/');
//		self::$DerivedNormalizationProps = resolvePath('data/utf8/DerivedNormalizationProps.txt');
//		self::$UnicodeData               = resolvePath('data/utf8/UnicodeData.txt');
//		self::$CompositionExclusions     = resolvePath('data/utf8/CompositionExclusions.txt');
	}


	// Generate regular expression from unicode database
	// to check if an UTF-8 string needs normalization
	// $type = NFC | NFD | NFKC | NFKD

	static function quickCheck($type)
	{
		$rx = '';

		$h = fopen(self::$DerivedNormalizationProps, 'rt');
		while (false !== $m = fgets($h))
		{
			if (preg_match('/^([0-9A-F]+(?:\.\.[0-9A-F]+)?)\s*;\s*' . $type . '_QC\s*;\s*[MN]/', $m, $m))
			{
				$m = explode('..', $m[1]);
				$rx .= '\x{' . $m[0] . '}' . (isset($m[1]) ? (hexdec($m[0])+1 == hexdec($m[1]) ? '' : '-') . '\x{' . $m[1] . '}' : '');
			}
		}

		fclose($h);

		return $rx;
	}


	// Generate regular expression from unicode database
	// to check if an UTF-8 string contains combining chars

	static function combiningCheck()
	{
		$rx = '';

		$lastChr = '';
		$lastOrd = 0;
		$interval = 0;

		$h = fopen(self::$UnicodeData, 'rt');
		while (false !== $m = fgets($h))
		{
			if (preg_match( '/^([0-9A-F]+);[^;]*;[^;]*;([1-9]\d*)/', $m, $m))
			{
				$ord = hexdec($m[1]);

				if ($lastOrd+1 == $ord)
				{
					++$lastOrd;
					++$interval;
				}
				else
				{
					$interval && $rx .= ($interval > 1 ? '-' : '') . $lastChr;

					$lastChr = '\x{' . $m[1] . '}';
					$lastOrd = $ord;
					$interval = 0;

					$rx .= $lastChr;

				}
			}
		}

		fclose($h);

		return $rx;
	}


	// Write the 4+1 above regular expressions to disk

	static function quickChecks()
	{
		$a = 'Generated by utf8_generate::quickChecks()'
			. "\n" . self::quickCheck('NFC')
			. "\n" . self::quickCheck('NFD')
			. "\n" . self::quickCheck('NFKC')
			. "\n" . self::quickCheck('NFKD')
			. "\n" . self::combiningCheck();

		$a = preg_replace("'\\\\x\\{([0-9A-F]+)\\}'e", 'u::chr(hexdec("$1"))', $a);

		file_put_contents(self::$utf8Data . 'quickChecks.txt', $a);
	}


	// Write unicode data maps to disk

	static function unicodeMaps()
	{
		$combiningClass = array();
		$canonicalComposition = array();
		$canonicalDecomposition = array();
		$compatibilityDecomposition = array();


		$exclusion = array();

		$h = fopen(self::$CompositionExclusions, 'rt');
		while (false !== $m = fgets($h))
		{
			if (preg_match('/^(?:# )?([0-9A-F]+) /', $m, $m))
			{
				$exclusion[u::chr(hexdec($m[1]))] = 1;
			}
		}

		fclose($h);


		$h = fopen(self::$UnicodeData, 'rt');
		while (false !== $m = fgets($h))
		{
			$m = explode(';', $m);

			$k = u::chr(hexdec($m[0]));
			$combClass = (int) $m[3];
			$decomp = $m[5];

			$combClass && $combiningClass[$k] = $combClass;

			if ($decomp)
			{
				$canonic = '<' != $decomp[0];
				$canonic || $decomp = preg_replace("'^<.*> '", '', $decomp);

				$decomp = explode(' ', $decomp);

				$exclude = count($decomp) == 1 || isset($exclusion[$k]);

				$decomp = array_map('hexdec', $decomp);
				$decomp = array_map(array('u','chr'), $decomp);
				$decomp = implode('', $decomp);

				$compatibilityDecomposition[$k] = $decomp;

				if ($canonic)
				{
					$canonicalDecomposition[$k] = $decomp;
					$exclude || $canonicalComposition[$decomp] = $k;
				}
			}
		}

		fclose($h);

		uksort($canonicalComposition, array(__CLASS__, 'cmpByLength'));

		$combiningClass = serialize($combiningClass);
		$canonicalComposition = serialize($canonicalComposition);
		$canonicalDecomposition = serialize($canonicalDecomposition);
		$compatibilityDecomposition = serialize($compatibilityDecomposition);

		file_put_contents(self::$utf8Data . 'combiningClass.ser', $combiningClass);
		file_put_contents(self::$utf8Data . 'canonicalComposition.ser', $canonicalComposition);
		file_put_contents(self::$utf8Data . 'canonicalDecomposition.ser', $canonicalDecomposition);
		file_put_contents(self::$utf8Data . 'compatibilityDecomposition.ser', $compatibilityDecomposition);
	}

	static function cmpByLength($a, $b)
	{
		return strlen($b) - strlen($a);
	}
}
